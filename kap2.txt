#process
Abstraciton of a running program.
Conceptually, each process has its own CPU.
Han program, input, output and a state.
Daemon is a background process.

#process_creation
	1. System initialization.
	2. Execution of a process creating system call by a running process.
	3. A user request.
	4. Initiation of a batch job.
Technically, all are made from a process issuing a system call.

#process_termination
	1. Normal exit
	2. Errlor exit
	3. Fatal error
	4. Killed by another process
	
#process_state
	1. Running
	2. Ready
	3. Blocked
	
#process_implementation
Systemet opprettholder en "process table", inneholder stackpointer, program counter osv osv, slik at den kan restartes.

#interrupt
#interrupt vector: Address of the interrupt service procedure.
Alle interrupts starter med å lagre registrene i prosesstabellen. 
	1. Hardware stacks program counter
	2. hardware loads new program counter from vector
	3. Assebly saves registers
	4. Assembly language sets up new stack
	5. C interrupt service runs
	6. Scheduler decides which process to run next.
	7. C procedure returns to the assembly code
	8. Assembly language procedure starts up new current process.

#process_vs_program
Recipe is the program, the computer scientist is the processor and the cake ingredients are the input data. The process is the activity of baking the cake.

#pseudoparallelism
Awesome word.

#threads
Hovedgrunnen er at man har flere ting som foregår samtidig. Man får en enklere programmeringsmodell.
Dette er det samme som prosesser, men det er forskjeller. Tråder ser samme data. Billigere å lage.
Kan være mer effektivt med mye IO.
Nyttig på flerkjerne-prosessorer.
Man kan ha tråder med blokkerende kall. "Blocking system calls make programming easier, and parallelism improves performance"
Tråden har en programteller som forteller hvilken intstruksjon som skal kjøres neste gang. Har registre, stakk.
Tråder samarbeider, de sloss ikke om ressursene.
Finnes Pthreads, POSIX-standard for tråder.

#threads_user_kernel_space
User space: Kan implementeres på OS som ikke støtter flertråd.
Fordeler med user space:
	- OS som ikke har flertråd.
	- Veldig rask
	- Egen skeduleringsarlgoritme.
Problemer med user space:
	- Må lage "jackets" for systemkall, slik at hele prosessen ikke fryser
	- Alle tråder må frivillig gi opp CPU, siden det ikke finnes noen interrupts.
	- Mange applikasjoner som støtter flertråd, må gjøre mange systemkall uansett.
	
Problemer med kernel space:
	- Dyrt.
Fordeler:
	- Lettere med blocking calls.
	
	
#interprocess_communication
How to make processes communicate and interleave.
Tråder gjør det enkelt å utveksle data, men kan likevel komme i veien for hverandre.
Spooling kan gjøre dette (legge inn filer som behandles siden)
Race conditions er noe drit.

#critical_region
En god løsning:
	- Ingen prosesser kan være inni sin kritiske region samtidig
	- Ingen antagelser om hastighet og antall CPU
	- Ingen prosess som er utenfor sin kritiske region kan blokkere andre prosesser.
	- Ingen prosess skal trenge å vente evig på å komme inn i sin kritiske rigon.
	
Dårlig løsning: Disablign av interrupts. Dette går i OS-kode, men ikke brukerkode (glemme å skru på).

#spin_lock: A lock that uses busy waiting.

#petersons_solution: Holde en liste over interesserte prosesser, og bare holde hvis det er andre som er interesserte.

#TSL_instruction: atomisk intruksjon på prosessoren.

